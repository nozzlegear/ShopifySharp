#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json.Linq;
using ShopifySharp.Entities;
using ShopifySharp.Enums;
using ShopifySharp.Infrastructure;

namespace ShopifySharp.Utilities;

public interface IShopifyOauthUtility
{
    /// <summary>
    /// Builds an OAuth authorization URL for Shopify OAuth integration.
    /// </summary>
    /// <param name="scopes">An array of <see cref="AuthorizationScope"/> â€” the permissions that your app needs to run.</param>
    /// <param name="shopDomain">The shop's *.myshopify.com URL.</param>
    /// <param name="clientId">Your app's public Client ID, also known as its public API key.</param>
    /// <param name="redirectUrl">URL to redirect the user to after integration.</param>
    /// <param name="state">An optional, random string value provided by your application which is unique for each authorization request. During the OAuth callback phase, your application should check that this value matches the one you provided to this method.</param>
    /// <param name="grants">Requested grant types, which will change the type of access token granted upon OAuth completion.</param>
    Uri BuildAuthorizationUrl(
        IEnumerable<AuthorizationScope> scopes,
        string shopDomain,
        string clientId,
        string redirectUrl,
        string? state = null,
        IEnumerable<string>? grants = null
    );

    /// <summary>
    /// Builds an OAuth authorization URL for Shopify OAuth integration.
    /// </summary>
    /// <param name="scopes">An array of Shopify permission strings, e.g. 'read_orders' or 'write_script_tags'. These are the permissions that your app needs to run.</param>
    /// <param name="shopDomain">The shop's *.myshopify.com URL.</param>
    /// <param name="clientId">Your app's public Client ID, also known as its public API key.</param>
    /// <param name="redirectUrl">URL to redirect the user to after integration.</param>
    /// <param name="state">An optional, random string value provided by your application which is unique for each authorization request. During the OAuth callback phase, your application should check that this value matches the one you provided to this method.</param>
    /// <param name="grants">Requested grant types, which will change the type of access token granted upon OAuth completion.</param>
    Uri BuildAuthorizationUrl(
        IEnumerable<string> scopes,
        string shopDomain,
        string clientId,
        string redirectUrl,
        string? state = null,
        IEnumerable<string>? grants = null
    );

    /// <summary>
    /// Builds an OAuth authorization URL for Shopify OAuth integration.
    /// </summary>
    /// <param name="options">Options for building the OAuth URL.</param>
    Uri BuildAuthorizationUrl(AuthorizationUrlOptions options);

    /// <summary>
    /// Authorizes an application installation, generating an access token for the given shop.
    /// </summary>
    /// <param name="code">The authorization code generated by Shopify, which is attached to the redirect querystring when Shopify redirects the user back to your app.</param>
    /// <param name="shopDomain">The store's *.myshopify.com URL, which is attached as a parameter named <c>shop</c> on the redirect querystring.</param>
    /// <param name="clientId">Your app's public Client ID, also known as its public API key.</param>
    /// <param name="clientSecret">Your app's Client Secret, also known as its secret API key.</param>
    Task<AuthorizationResult> AuthorizeAsync(
        string code,
        string shopDomain,
        string clientId,
        string clientSecret
    );

    #if NET8_0_OR_GREATER
    /// <summary>
    /// Authorizes an application installation, generating an access token for the given shop.
    /// </summary>
    /// <param name="options">Options for performing the authorization.</param>
    Task<AuthorizationResult> AuthorizeAsync(AuthorizeOptions options);
    #endif

    /// <summary>
    /// Refreshes an existing store access token using the app's client secret and a refresh token
    /// For more info on rotating tokens, see https://shopify.dev/apps/auth/oauth/rotate-revoke-client-credentials
    /// </summary>
    /// <param name="shopDomain">The store's *.myshopify.com url</param>
    /// <param name="clientId">Your app's public Client ID, also known as its public API key.</param>
    /// <param name="clientSecret">Your app's Client Secret, also known as its secret API key.</param>
    /// <param name="refreshToken">The app's refresh token</param>
    /// <param name="existingStoreAccessToken">The existing store access token</param>
    Task<AuthorizationResult> RefreshAccessTokenAsync(
        string shopDomain,
        string clientId,
        string clientSecret,
        string refreshToken,
        string existingStoreAccessToken
    );

    #if NET8_0_OR_GREATER
    /// <summary>
    /// Refreshes an existing store access token using the app's client secret and a refresh token
    /// For more info on rotating tokens, see https://shopify.dev/apps/auth/oauth/rotate-revoke-client-credentials
    /// </summary>
    /// <param name="options">Options for refreshing the access token.</param>
    Task<AuthorizationResult> RefreshAccessTokenAsync(RefreshAccessTokenOptions options);
    #endif
}

public class ShopifyOauthUtility: IShopifyOauthUtility
{
    private const string AccessTokenPropertyName = "access_token";
    private const string ExpiresInPropertyName = "expires_in";
    private const string AssociatedUserPropertyName = "associated_user";
    private const string AssociatedUserScopePropertyName = "associated_user_scope";
    private const string ScopePropertyName = "scope";

    private readonly IHttpClientFactory _httpClientFactory;
    private readonly IShopifyDomainUtility _domainUtility;

    public ShopifyOauthUtility(IShopifyDomainUtility? domainUtility = null)
    {
        _httpClientFactory = new InternalHttpClientFactory();
        _domainUtility = domainUtility ?? new ShopifyDomainUtility();
    }

    internal ShopifyOauthUtility(IServiceProvider serviceProvider)
    {
        _httpClientFactory = InternalServiceResolver.GetServiceOrDefault<IHttpClientFactory>(
            serviceProvider, () => new InternalHttpClientFactory());
        _domainUtility = InternalServiceResolver.GetServiceOrDefault<IShopifyDomainUtility>(
            serviceProvider, () => new ShopifyDomainUtility());
    }

    /// <inheritdoc />
    public Uri BuildAuthorizationUrl(
        IEnumerable<AuthorizationScope> scopes,
        string shopDomain,
        string clientId,
        string redirectUrl,
        string? state = null,
        IEnumerable<string>? grants = null
    ) => BuildAuthorizationUrl(new AuthorizationUrlOptions
    {
        Scopes = scopes.Select(s => s.ToSerializedString()),
        ShopDomain = shopDomain,
        ClientId = clientId,
        RedirectUrl = redirectUrl,
        State = state,
#pragma warning disable CS0618 // Type or member is obsolete
        Grants = grants,
#pragma warning restore CS0618 // Type or member is obsolete
    });

    /// <inheritdoc />
    public Uri BuildAuthorizationUrl(
        IEnumerable<string> scopes,
        string shopDomain,
        string clientId,
        string redirectUrl,
        string? state = null,
        IEnumerable<string>? grants = null
    ) => BuildAuthorizationUrl(new AuthorizationUrlOptions
    {
        Scopes = scopes,
        ShopDomain = shopDomain,
        ClientId = clientId,
        RedirectUrl = redirectUrl,
        State = state,
#pragma warning disable CS0618 // Type or member is obsolete
        Grants = grants,
#pragma warning restore CS0618 // Type or member is obsolete
    });

    /// <inheritdoc />
    public Uri BuildAuthorizationUrl(AuthorizationUrlOptions options)
    {
        var builder = new UriBuilder(_domainUtility.BuildShopDomainUri(options.ShopDomain));
        var qs = new List<(string, string)>
        {
            ("client_id", options.ClientId),
            ("scope", string.Join(",", options.Scopes)),
            ("redirect_uri", options.RedirectUrl),
        };

        if (!string.IsNullOrEmpty(options.State))
            qs.Add(("state", options.State!));

        if (options.AuthorizationAccessMode == AuthorizationAccessMode.Online)
        {
            // To use the online access mode, set the grant_options[] value to per_user
            qs.Add(("grant_options[]", "per_user"));

#pragma warning disable CS0618 // Type or member is obsolete
            if (options.Grants?.Any() == true)
                throw new ArgumentException($"Invalid {nameof(AuthorizationUrlOptions)}. Cannot use the obsolete {nameof(options.Grants)} alongside {nameof(options.AuthorizationAccessMode)}.");
        }
        else if (options.Grants?.ToList() is { Count: >= 1 } grants)
#pragma warning restore CS0618 // Type or member is obsolete
        {
            qs.AddRange(grants.Select(grant => ("grant_options[]", grant)));
        }

        builder.Path = "admin/oauth/authorize";
        builder.Query = string.Join("&", qs.Select(pairs => $"{pairs.Item1}={pairs.Item2}"));

        return builder.Uri;
    }

    /// <inheritdoc />
    public async Task<AuthorizationResult> AuthorizeAsync(
        string code,
        string shopDomain,
        string clientId,
        string clientSecret
    )
    {
        var ub = new UriBuilder(_domainUtility.BuildShopDomainUri(shopDomain))
        {
            Path = "admin/oauth/access_token"
        };
        var content = new JsonContent(new
        {
            client_id = clientId,
            client_secret = clientSecret,
            code,
        });

        var client = _httpClientFactory.CreateClient(nameof(ShopifyOauthUtility));
        using var request = new CloneableRequestMessage(ub.Uri, HttpMethod.Post, content);
        using var response = await client.SendAsync(request, CancellationToken.None);
        var rawDataString = await response.Content.ReadAsStringAsync();

        ShopifyService.CheckResponseExceptions(await request.GetRequestInfo(), response, rawDataString);

        var json = JToken.Parse(rawDataString);
        var scopes = json.Value<string>(ScopePropertyName)?.Trim().Split(',');
        var accessToken = json.Value<string>(AccessTokenPropertyName);

        if (string.IsNullOrEmpty(accessToken))
            throw new ShopifyJsonParseException(
                $"The JSON response from Shopify does not contain a valid '{AccessTokenPropertyName}' property.",
                AccessTokenPropertyName
            );

        OnlineAccessInfo? onlineAccessInfo = null;

        var user = json.Value<JToken>(AssociatedUserPropertyName);

        if (user is { HasValues: true })
        {
            var expiresIn = json.Value<JToken>(ExpiresInPropertyName);

            if (expiresIn is null or { HasValues: false })
                throw new ShopifyJsonParseException(
                    "The JSON response from Shopify does not contain a valid 'expires_in' property. The property was null or missing.",
                    ExpiresInPropertyName
                );

            onlineAccessInfo = new OnlineAccessInfo
            {
                ExpiresIn = TimeSpan.FromSeconds(expiresIn.Value<int>()),
                AssociatedUserScopes = json.Value<string>(AssociatedUserScopePropertyName)?.Split(',') ?? [],
                AssociatedUser = user.Value<AssociatedUser>()!,
            };
        }

        return new AuthorizationResult(accessToken!, scopes?.Where(str => !string.IsNullOrWhiteSpace(str)).ToArray())
        {
            OnlineAccess = onlineAccessInfo
        };
    }

    #if NET8_0_OR_GREATER
    /// <inheritdoc />
    public Task<AuthorizationResult> AuthorizeAsync(AuthorizeOptions options) =>
        AuthorizeAsync(
            options.Code,
            options.ShopDomain,
            options.ClientId,
            options.ClientSecret
        );
    #endif

    /// <inheritdoc />
    public async Task<AuthorizationResult> RefreshAccessTokenAsync(
        string shopDomain,
        string clientId,
        string clientSecret,
        string refreshToken,
        string existingStoreAccessToken
    )
    {
        var ub = new UriBuilder(_domainUtility.BuildShopDomainUri(shopDomain))
        {
            Path = "admin/oauth/access_token"
        };
        var content = new JsonContent(new
        {
            client_id = clientId,
            client_secret = clientSecret,
            refresh_token = refreshToken,
            access_token = existingStoreAccessToken
        });

        var client = _httpClientFactory.CreateClient(nameof(ShopifyOauthUtility));
        using var request = new CloneableRequestMessage(ub.Uri, HttpMethod.Post, content);
        using var response = await client.SendAsync(request);
        var rawDataString = await response.Content.ReadAsStringAsync();

        ShopifyService.CheckResponseExceptions(await request.GetRequestInfo(), response, rawDataString);

        var json = JToken.Parse(rawDataString);
        var accessToken = json.Value<string>("access_token");

        if (string.IsNullOrEmpty(accessToken))
            throw new ShopifyJsonParseException(
                $"The JSON response from Shopify does not contain a valid '{AccessTokenPropertyName}' property.",
                AccessTokenPropertyName
            );

        return new AuthorizationResult(accessToken!, json.Value<string>(ScopePropertyName)?.Split(','));
    }

    #if NET8_0_OR_GREATER
    /// <inheritdoc />
    public Task<AuthorizationResult> RefreshAccessTokenAsync(RefreshAccessTokenOptions options) =>
        RefreshAccessTokenAsync(
            options.ShopDomain,
            options.ClientId,
            options.ClientSecret,
            options.RefreshToken,
            options.ExistingStoreAccessToken
        );
    #endif
}
